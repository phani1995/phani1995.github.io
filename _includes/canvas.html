
<div>
    <canvas></canvas>
    
    <script>

        var canvas = document.querySelector('canvas');
        canvas.width  = window.innerWidth;
        canvas.height = window.innerHeight;
        //canvas.height = 600;

        var c = canvas.getContext('2d');
       
        var mouse = {
            x: undefined,
            y: undefined
        }

        var maxRadius = 100;
        var minRadius = 50;

        var colorArray = [
            '#1E4363',
            '#FCF2CB',
            '#FFB00D',
            '#FF8926',
            '#BC2D19'
        ];

        var algoArray = [
            'Machine learning',
            'classification',
            'regression',
            'Gradient descent algorithm',
            'clustering',
            'association',
            'decision trees',
            'support vector machines',
            'neural networks',
            'deep learning',
            'reinforcement learning',
            'bayesian',
            'Cross validation',
            'Robotics',
            'Computational neural networks',
            'Natural language processing',
            'database',
            'computer vision',
            'Supervised learning',
            'unsupervised learning',
            'Reinforcement learning',
            'Overfitting'
        ]

        var nearestCircle = null;
        var circleArray = [];


        window.addEventListener('mousemove',
            function(event){
                mouse.x = event.x;
                mouse.y = event.y;
        })

        window.addEventListener('resize',
            function(){
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                init();
            })

        
        window.addEventListener('click',
            function(){
               alert(nearestCircle.name)
               window.location.href = "/posts/linear/regression/2018/09/28/linear_regression_using_scikit_learn.html";
               circleInFocus = nearestCircle
               c.beginPath();
                c.arc(canvas.width/2,canvas.height/2,circleInFocus.radius*10,0, Math.PI*2,false);
                c.fillStyle = circleInFocus.color
                c.stroke();
                c.fill();
                
                ctx = canvas.getContext("2d");
                ctx.font = '19pt Calibri';
                ctx.fillStyle = 'black';
                ctx.textAlign = 'center';
                ctx.fillText(circleInFocus.name, circleInFocus.x, circleInFocus.y+3);

            })
        
        function getDistance(x1,y1,x2,y2){
            let xDistance = x2-x1;
            let yDistance = y2-y1;

            return Math.sqrt(Math.pow(xDistance,2)+ Math.pow(yDistance,2));
        }
        function rotate(dx,dy, angle) {
            const rotatedVelocities = {
                x: dx * Math.cos(angle) - dy * Math.sin(angle),
                y: dx * Math.sin(angle) + dy * Math.cos(angle)
            };
            console.log('The is output of rotate function',rotatedVelocities)
            return rotatedVelocities;
        }

        function resolveCollision(particle, otherParticle) {
            const xVelocityDiff = particle.dx - otherParticle.dx;
            const yVelocityDiff = particle.dy - otherParticle.dy;
           
            const xDist = otherParticle.x - particle.x;
            const yDist = otherParticle.y - particle.y;

            // Prevent accidental overlap of particles
            if (xVelocityDiff * xDist + yVelocityDiff * yDist >= 0) {

                // Grab angle between the two colliding particles
                const angle = -Math.atan2(otherParticle.y - particle.y, otherParticle.x - particle.x);

                // Store mass in var for better readability in collision equation
                const m1 = particle.mass;
                const m2 = otherParticle.mass;

                // Velocity before equation
                const u1 = rotate(particle.dx,particle.dy, angle);
                const u2 = rotate(otherParticle.dx,otherParticle.dy, angle);

                // Velocity after 1d collision equation
                const v1 = { x: u1.x * (m1 - m2) / (m1 + m2) + u2.x * 2 * m2 / (m1 + m2), y: u1.y };
                const v2 = { x: u2.x * (m1 - m2) / (m1 + m2) + u1.x * 2 * m2 / (m1 + m2), y: u2.y };

                console.log("this is v1 and v2",v1,v2);

                // Final velocity after rotating axis back to original location
                const vFinal1 = rotate(v1.x,v1.y, -angle);
                const vFinal2 = rotate(v2.x,v2.y, -angle);
                

                // Swap particle velocities for realistic bounce effect
                particle.dx = vFinal1.x;
                particle.dy = vFinal1.y;

                otherParticle.dx = vFinal2.x;
                otherParticle.dy = vFinal2.y;
                
            }
            console.log('I am here')
        }


        function Circle(x,y,dx,dy,radius,name){
            this.x = x;
            this.y = y;
            this.dx = dx;
            this.dy = dy;
            this.radius = radius;
            this.mass = 1;
            this.name = name;
            this.minRadius = radius;
            this.color = colorArray[Math.floor(Math.random()* colorArray.length)]

            this.draw = function(){
                c.beginPath();
                c.arc(this.x,this.y,this.radius,0, Math.PI*2,false);
                c.fillStyle = this.color
                c.stroke();
                c.fill();

                
                
                //console.log('circle draw')
            }

            this.update = circleArray =>
            {
                this.draw();

                //console.log(circleArray)

                //Collision detection
                for (let i =0 ;i <circleArray.length;i++)
                {
                    if(this === circleArray[i]) continue;
                    if(getDistance(this.x,this.y,circleArray[i].x,circleArray[i].y)- this.radius*2 <0)
                    {
                        console.log(this.dx,this.dy)
                        console.log('had collied');
                        resolveCollision(this,circleArray[i])
                        console.log(this.dx,this.dy)
                    }
                }

                if(this.x + radius> innerWidth || this.x-radius < 0)
                {
                    this.dx = -this.dx;
                }
                if(this.y+radius>innerHeight || this.y-radius<0)
                {
                    this.dy = -this.dy;
                }
                this.x+= this.dx;
                this.y+= this.dy;

                ctx = canvas.getContext("2d");
                ctx.font = '19pt Calibri';
                ctx.fillStyle = 'black';
                ctx.textAlign = 'center';
                ctx.fillText(this.name, this.x, this.y+3);
                //ctx.fillText(this.name, this.x, this.y+19);

                /*
                // Finding the nearest circle
                nearestCircle = null;
                var nearestDist = 100000
                circleArray.forEach(function(circle) {
                    var dist = Math.sqrt(Math.pow(mouse.x-circle.x,2)+Math.pow(mouse.y-circle.y,2))
                  
                    if (dist < nearestDist)
                    {
                        nearestCircle = circle;
                        nearestDist = dist;
                    }
                });
                console.log('the nearest distance is :',nearestDist,'circle name:',nearestCircle.name)
                */
               

                if(mouse.x - this.x < 50 && mouse.x - this.x>-50
                    && mouse.y-this.y<50 && mouse.y-this.y >-50)
                {
                    if(this.radius < maxRadius)
                    {
                        this.radius +=1;
                    }
                    
            
                }
                else if (this.radius> this.minRadius)
                {
                    this.radius -=1;
                }


                
                /*
                c.beginPath();
                c.arc(canvas.width/2,canvas.height/2,circleInFocus.radius*5,0, Math.PI*2,false);
                c.fillStyle = circleInFocus.color
                c.stroke();
                c.fill();
                
                ctx = canvas.getContext("2d");
                ctx.font = '19pt Calibri';
                ctx.fillStyle = 'black';
                ctx.textAlign = 'center';
                ctx.fillText(circleInFocus.name, circleInFocus.x, circleInFocus.y+3);*/
            }

        }



       
        
        /*function init(){
            circleArray = [];
            for (var i=0;i<algoArray.length;i++){
                var radius = minRadius;
                var x = Math.random()*(innerWidth - radius*2) + radius;
                var y = Math.random()*(innerHeight- radius*2) + radius;
                var dx = (Math.random() - 0.5)*1;
                var dy = (Math.random() - 0.5)*1;
                var name = algoArray[i]
            
                circleArray.push(new Circle(x,y,dx,dy,radius,name));
                }
        }*/


        function init() {
            circleArray = [];

            for (let i = 0 ;i < algoArray.length ;i++)
            {
                var radius = minRadius;
                var x = Math.random()*(innerWidth - radius*2) + radius;
                var y = Math.random()*(innerHeight- radius*2) + radius;
                var dx = (Math.random() - 0.5)*2;
                var dy = (Math.random() - 0.5)*2;
                var name = algoArray[i]

                if (i !== 0)
                {
                    for (let j = 0 ;j < circleArray.length;j++)
                    {
                        if(getDistance(x,y,circleArray[j].x,circleArray[j].y)-radius*2 <0)
                        {
                            x = Math.random() * innerWidth;
                            y = Math.random() * innerHeight;
                            j = -1;
                        }
                    }
                }
                circleArray.push(new Circle(x,y,dx,dy,radius,name));

             
            }
        }

        init()

        function animate(){
            requestAnimationFrame(animate);
            c.clearRect(0,0,innerWidth,innerHeight);
            for (var i=0; i <circleArray.length;i++)
            {
                circleArray[i].update(circleArray);
            }
        }

        animate();

    </script>
</div>

